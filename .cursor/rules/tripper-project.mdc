# Tripper - Project Intelligence

## Project Overview
Tripper is a lightning-fast, offline-first trip planning application. Think "Trello meets Linear for travel."

**Core Philosophy:** Speed over features. Every interaction should feel instant.

## Tech Stack Essentials
- Next.js 15 (App Router) - Server components where possible
- Supabase - PostgreSQL database, authentication, cloud sync
- @supabase/ssr - Server-side rendering support for Supabase
- Zustand + Immer - State management with immutable updates
- Zundo - Temporal state (undo/redo) middleware for Zustand
- dnd-kit - Modern drag & drop (replaces react-beautiful-dnd)
- Sonner - Beautiful toast notifications
- Tailwind + shadcn/ui - Utility-first styling with accessible primitives
- Zod - Runtime validation and TypeScript inference
- date-fns - Date manipulation and formatting
- react-day-picker - Accessible date selection (Slingshot feature)
- Hybrid persistence: localStorage (instant) + Supabase (cloud sync)

## Critical Implementation Paths

### State Management Pattern
Always use Zustand with Immer for mutations:
```typescript
set((state) => {
  state.trips[tripId].days.push(newDay)  // Immer handles immutability
})
```

After state changes:
1. Save to localStorage (instant, via middleware)
2. Sync to Supabase (background, via services)

### Adding Features Checklist
1. Update types in `lib/types/index.ts`
2. Add Zod schema in `lib/schemas/index.ts`
3. Add service methods in `lib/services/` (if data access needed)
4. Add store action in `lib/store/tripStore.ts` (with Immer)
5. Create UI component in `components/`
6. Wire up component to store and services
7. Add toast notification feedback
8. Handle edge cases (null checks, special IDs, auth state)
9. Update database schema in `lib/supabase/database.sql` if needed
10. Update seed data if needed
11. Test with undo/redo
12. Test with authenticated and unauthenticated states

### Drag & Drop (IMPLEMENTED)
Use dnd-kit with these sensors:
- Mouse: 5px activation constraint
- Touch: 250ms delay + 5px tolerance
- Keyboard: sortableKeyboardCoordinates

**Important Patterns:**
- Days use `horizontalListSortingStrategy`
- Cards use `verticalListSortingStrategy`
- Always provide stable IDs (use nanoid)
- Use `DragOverlay` for visual feedback
- Handle both same-list and cross-list moves in `onDragEnd`
- Special dayId `"unassigned"` for "Things to Do" column

### Component Patterns
- Use compound components for complex UI (Card.Header, Card.Content)
- Extract custom hooks for reusable logic (useCardActions, useUndoRedo, useKeyboardShortcuts)
- Client components: Use 'use client' directive at top
- Server components: Default (no directive needed)

### Special Patterns Discovered

**Supabase Client/Server Pattern:**
```typescript
// Client-side (components)
import { createClient } from '@/lib/supabase/client'

const supabase = createClient()
const { data, error } = await supabase.from('trips').select()

// Server-side (API routes, Server Components)
import { createClient } from '@/lib/supabase/server'

const supabase = await createClient()
const { data, error } = await supabase.from('trips').select()
```

**Services Layer Pattern:**
```typescript
// Abstract data access in services
// lib/services/trips-service.ts
export async function getTrips(userId: string) {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('trips')
    .select('*, days(*, cards(*))')
    .eq('user_id', userId)
  
  if (error) throw error
  return data
}

// Components use services
import { getTrips } from '@/lib/services/trips-service'
const trips = await getTrips(user.id)
```

**Auth Middleware Pattern:**
```typescript
// middleware.ts protects routes
import { updateSession } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}
```

**Row-Level Security (RLS) Pattern:**
```sql
-- Users can only see their own trips
CREATE POLICY "Users can view own trips"
  ON trips FOR SELECT
  USING (auth.uid() = user_id);
```

**Unassigned Cards (Special ID Pattern):**
```typescript
// Use "unassigned" as a special dayId
if (dayId === 'unassigned') {
  // Handle unassigned cards array
  trip.unassignedCards = trip.unassignedCards || [];
  trip.unassignedCards.push(card);
} else {
  // Handle normal day cards
  const day = trip.days.find(d => d.id === dayId);
  day.cards.push(card);
}
```

**Hydration Fix (Client-Only Rendering):**
```typescript
// Prevent SSR/client mismatch for dynamic content
const [mounted, setMounted] = useState(false);
useEffect(() => { setMounted(true); }, []);

return <p>{mounted ? format(date) : rawDate}</p>;
```

**Inline Edit (Click-to-Edit):**
```typescript
// Intuitive editing pattern
const [isEditing, setIsEditing] = useState(false);

const handleSave = () => {
  updateData(value);
  setIsEditing(false);
  toast.success('Updated');
};

return isEditing ? (
  <Input 
    value={value}
    onBlur={handleSave}
    onKeyDown={(e) => {
      if (e.key === 'Enter') handleSave();
      if (e.key === 'Escape') setIsEditing(false);
    }}
    autoFocus 
  />
) : (
  <h1 onClick={() => setIsEditing(true)}>{value}</h1>
);
```

**Zundo Temporal Store Access:**
```typescript
// Access undo/redo reactively
import { useStore } from 'zustand';

const { undo, redo, pastStates, futureStates } = useStore(
  useTripStore.temporal,
  (state) => state
);
```

**Sequential AI Generation (Slingshot Pattern):**
```typescript
// Build context across multiple OpenAI calls
const previousDaysContext = days
  .map((day) => ({
    dayNumber: day.dayNumber,
    cards: day.cards.map(c => ({
      type: c.type,
      title: c.title,
      startTime: c.startTime
    }))
  }));

// Pass to next day generation
const prompt = `
Previous days:
${JSON.stringify(previousDaysContext)}

Now plan Day ${dayNumber}:
- Avoid duplicate restaurants from previous days
- Balance activity intensity
- Include logical transitions
`;
```

**One-Time Overlay Pattern:**
```typescript
// Track dismissible overlays in localStorage
const storageKey = `slingshot-explained-${tripId}`;
const [hasSeenOverlay, setHasSeenOverlay] = useState(() => {
  if (typeof window === 'undefined') return true;
  return localStorage.getItem(storageKey) === 'true';
});

const handleDismiss = () => {
  localStorage.setItem(storageKey, 'true');
  setHasSeenOverlay(true);
};

return !hasSeenOverlay && <Overlay onDismiss={handleDismiss} />;
```

## Known Constraints

### Performance Targets
- Card creation: < 100ms
- Drag frame rate: 60fps (16.67ms)
- Bundle size: < 200KB initial JS
- localStorage save: Debounced 500ms

### Accessibility Requirements
- WCAG 2.1 AA compliance mandatory
- Touch targets: ≥ 44x44px on mobile
- Keyboard navigation for ALL actions
- Screen reader support

### Browser Support
- Chrome/Edge 90+
- Firefox 88+
- Safari 14+
- Mobile: iOS 14+, Android 10+

## User Preferences Discovered
- Offline-first is non-negotiable
- Keyboard shortcuts are first-class (not "nice to have")
- Speed matters more than polish for MVP
- Mobile UX must match desktop feature parity

## Development Workflow

### Adding a New Card Type
1. Add type to `CardType` union in `lib/types/index.ts`
2. Add to `CARD_TYPES` in `lib/constants.ts` (icon, color)
3. Add template to `CARD_TEMPLATES`
4. Update CardComposer type selector

### Testing Strategy
- Unit: Zustand store actions (add/edit/delete/move)
- Integration: Card CRUD with Testing Library
- E2E: Drag flows with Playwright
- Manual: Touch gestures on real mobile device

## Common Pitfalls to Avoid
❌ Don't mutate state directly - always use Zustand's set()
❌ Don't forget to call debouncedSave() after state changes
❌ Don't use server components in client-only contexts (drag/drop)
❌ Don't skip keyboard navigation when adding mouse interactions
❌ Don't assume localStorage is available (SSR/SSG checks needed)
❌ Don't forget null checks on optional properties (card.links, card.tags)
❌ Don't format dates on server - causes hydration errors (use mounted state)
❌ Don't access zundo temporal store directly - use useStore(store.temporal)

## Future Architecture Decisions
- When adding Supabase: Keep localStorage as fallback
- When adding collaboration: Use Yjs or Automerge (CRDTs)
- When adding mobile app: Share types/schemas with React Native
- When adding AI: Use streaming responses for suggestions

## File Organization
```
lib/
  ├── types/        # TypeScript interfaces
  ├── schemas/      # Zod validation schemas
  ├── store/        # Zustand state management
  ├── services/     # Data access layer (NEW)
  ├── supabase/     # Supabase client/server/middleware (NEW)
  ├── utils/        # Pure utility functions
  └── constants.ts  # App-wide constants

components/
  ├── board/        # Board, DayColumn, AddDay
  ├── cards/        # TripCard, CardComposer
  ├── profile/      # Profile management (NEW)
  ├── migration/    # Data migration (NEW)
  └── ui/           # shadcn/ui primitives

app/
  ├── api/          # API routes
  ├── auth/         # Auth callbacks (NEW)
  ├── login/        # Authentication (NEW)
  ├── signup/       # Registration (NEW)
  ├── profile/      # User profile (NEW)
  ├── trips/        # Trips overview
  ├── trip/[id]/    # Individual trip
  └── demo/         # Demo trip page

middleware.ts       # Route protection (NEW)
```

## Evolution Notes
- Started with focus on MVP speed (2-3 evenings timeline)
- Prioritized localStorage over cloud sync for simplicity
- Chose dnd-kit over react-beautiful-dnd (maintenance)
- Using App Router despite learning curve (future-proof)

### Key Learnings (Phases 1-6)
1. **Unassigned Cards Pattern:** Use special dayId `"unassigned"` instead of creating fake days
2. **Dynamic Dates:** Recalculate dates on day reorder to maintain chronological order
3. **Hydration Fixes:** Use `mounted` state for client-only rendering (dates, dynamic content)
4. **Undo/Redo:** Access via `useStore(useTripStore.temporal)` for reactive updates
5. **Toast Notifications:** Keep messages brief, show for all mutations
6. **Inline Editing:** Click-to-edit pattern with Enter/Escape handling is intuitive
7. **Defensive Programming:** Always null-check optional properties before accessing
8. **Client-Only Components:** Mark with 'use client' and handle SSR appropriately
9. **Sequential AI Generation:** Build context across multiple OpenAI calls for coherent multi-day trips
10. **Context Building:** Pass previous days' data to next day generation to avoid duplicates and balance intensity
11. **One-Time Overlays:** Use localStorage to track dismissible overlays (e.g., `slingshot-explained-${tripId}`)
12. **Loading UX:** Rotate funny messages every 2.5s to keep users engaged during long AI operations
13. **Vibe Integration:** Always check for vibes before AI generation; redirect to /vibes if missing
14. **Date Selection:** React Day Picker with disabled past dates for intuitive date range selection

## Roadmap: Phases Completed & Planned

### Phase 4.4: Profile + Supabase (✅ COMPLETE - Nov 1, 2025)
- Supabase integration (auth, database, RLS)
- User authentication (email/password, OAuth)
- Profile management (info, preferences, security)
- Cloud synchronization
- Data migration from localStorage
- Services layer abstraction
- Auth middleware for route protection
- **Result:** Production-ready with cloud sync

### Phase 4.5: Mobile Optimization (✅ COMPLETE - Nov 5, 2025)
- Mobile detection hook (useIsMobile)
- Responsive board layout (vertical stacking on mobile)
- Touch-friendly interactions (44px targets)
- Full-screen modals on mobile
- Mobile-specific CSS utilities
- **Result:** Full mobile parity

### Phase 4.6: Slingshot AI Trip Generator (✅ COMPLETE - Nov 11, 2025)
- AI-powered complete trip generation
- Comprehensive questionnaire (8 fields)
- Sequential day generation with context building
- Vibe integration and personalization
- Loading experience with progress updates
- One-time vibe explanation overlay
- React Day Picker integration
- **Result:** One-click trip generation with AI

### Phase 4.7: Affiliate Links (Planned - 6-8 hours)
- Booking.com, Skyscanner, Viator integration
- Link generators with parameter extraction
- BookingActions component
- Revenue tracking
- **Result:** Monetization ready

### Phase 5: Multi-Select & Bulk Operations (1 evening)
- Multi-select with Shift/Ctrl modifiers
- Checkbox overlays on cards
- Floating action bar for bulk operations
- Drag multiple cards as groups
- Full keyboard navigation
- **Key Decision:** Use Set<string> for O(1) selection lookup

### Phase 6: Cloud Sync & Authentication (2 evenings)
- Supabase integration (PostgreSQL + Auth + Realtime)
- Email/password + social auth
- Optimistic updates with rollback
- Background sync every 30s
- Last-write-wins conflict resolution
- **Key Decision:** Supabase chosen over Firebase for better PostgreSQL

### Phase 7: Advanced Features & AI (3-4 evenings)
- AI day planner (GPT-4 for complex planning)
- Mapbox maps integration
- Travel time calculations
- Natural language card creation
- Basic collaboration (share, comments)
- **Key Decisions:** 
  - Mapbox > Google Maps (pricing)
  - GPT-4 for planning, GPT-4o-mini for quick suggestions

### Phase 8: Mobile & Real-Time Collaboration (4-6 evenings)
- Progressive Web App (PWA)
- React Native mobile apps (iOS/Android)
- Yjs CRDTs for real-time collaboration
- Live cursors and presence
- Trip templates marketplace
- Budget tracking and PDF export
- **Key Decisions:**
  - PWA first (faster to ship)
  - Yjs for CRDTs (battle-tested)
  - PostHog for analytics, Sentry for errors

## Version Milestones
- **MVP (Post-Phase 4.3):** Offline planner, no auth ✅
- **v0.9 (Post-Phase 4.4):** Cloud sync, auth ✅
- **v0.95 (Post-Phase 4.5):** Mobile optimization ✅
- **v0.96 (Post-Phase 4.6):** Slingshot AI trip generator ✅ CURRENT
- **v1.0 (Post-Phase 4.7):** Affiliate links, revenue generation
- **v1.5 (Post-Phase 5-6):** Multi-select, visual polish, AI improvements
- **v2.0 (Future):** Mobile apps, real-time collaboration, premium features

## Monetization (Planned for v2.0)
- **Free:** 5 trips, basic AI (10/month), localStorage only
- **Pro ($8/mo):** Unlimited trips/AI, cloud sync, collaboration (5 people)
- **Teams ($20/mo):** Unlimited collaborators, real-time, analytics, SSO

## Timeline Estimate
- **Phases 1-3:** 3 evenings (✅ COMPLETE)
- **Phase 4.1-4.4:** 8-10 hours (✅ COMPLETE)
- **Phase 4.5-4.6:** 10-12 hours (✅ COMPLETE)
- **Phase 4.7:** 6-8 hours (⏳ PLANNED)
- **Phases 5-6:** 8-10 hours (⏳ PLANNED)
- **Total to v1.0:** ~46-56 hours
- **Total to v2.0:** ~90-110 hours